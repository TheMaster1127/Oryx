# Oryx Programming Language

Oryx is a minimal, portable, and easily embeddable interpreted programming language.

## Table of Contents
1.  [Vision & Philosophy](#vision--philosophy)
2.  [Key Features](#key-features)
3.  [Project Status](#project-status)
4.  [Embedding the VM](#embedding-the-vm)
5.  [License](#license)

---

## Vision & Philosophy

Oryx is designed to be a simple, powerful scripting language, similar in spirit to Lua. It prioritizes portability and ease of embedding, making it an ideal choice for adding scripting capabilities to game engines, web applications, and command-line tools.

The project is being developed in two main stages:
1.  **The Backend (Complete):** The **Oryx Virtual Machine (VM)** and its **Intermediate Representation (Oryx IR)**. This is the execution engine that runs the low-level instructions.
2.  **The Frontend (In Development):** The **Oryx Language** itself, which will feature a high-level, user-friendly syntax that compiles down to Oryx IR.

While other developers *can* create their own languages that target the Oryx VM, the primary goal is to deliver a complete, first-party language experience with Oryx.

---

## Key Features

*   **Extreme Portability:** Oryx is written in **HTVM**, a language that transpiles to multiple high-level languages. This means the Oryx VM library is available for direct use in projects written in:
    *   **C++**
    *   **JavaScript / TypeScript**
    *   **Python**
    The behavior of the VM is identical across all these platforms.

*   **Easily Embeddable:** The entire VM is designed to be used as a library. Simply include the source file in your project and call a single function to execute code.

*   **Zero External Dependencies:**
    *   The **JavaScript** and **Python** versions require no external libraries.
    *   The **C++** version relies only on standard libraries.
    *   *Note:* The **TypeScript** version requires the `fs` module for file operations when run in a Node.js environment.

---

## Project Status

The project is currently in **Stage 1: Backend Complete**.

The Oryx VM and its Intermediate Representation (Oryx IR) are finished, stable, and ready for use. You can write code directly in Oryx IR and execute it by embedding the VM in a host application.

The next stage is the development of the high-level Oryx language front-end.

---

## Embedding the VM

The API is intentionally simple, consisting of a main execution function and several helper functions for retrieving state.

### `Oryx_VM(code)`
The main entry point. Executes a string of Oryx IR code.
*   **Parameter:** `code` (string) - The Oryx IR source code to execute.
*   **Returns:** (string) - `"success"` or an error message.

### `OryxAPI_GetVariable(name)`
Retrieves the final value of a variable or register after the VM has finished executing.
*   **Parameter:** `name` (string) - The name of the variable (e.g., `"my_var"`) or register (e.g., `"r1"`).
*   **Returns:** (string) - The final value of the variable.

### `OryxAPI_GetArray(name)`
Retrieves the final contents of an array as a list/array in the host language.
*   **Parameter:** `name` (string) - The name of the array (e.g., `"my_list"`).
*   **Returns:** (array of strings) - The contents of the array.

#### Python Embedding Example

```python
# First, ensure the transpiled 'oryx_vm.py' library is in the same directory.
# This file is generated by HTVM from the original source.
from oryx_vm import Oryx_VM

# Read Oryx IR code from a file into a string
with open('my_script.oryxir', 'r') as f:
    oryx_code = f.read()

print("--- Running Oryx VM ---")

# Execute the code by calling the main VM function
result = Oryx_VM(oryx_code)

print("--- Oryx VM Finished ---")
print(f"VM exit state: {result}")
```
*You must replace `oryx_vm` with the correct name of the generated Python file.*

---

## License

This project is licensed under the **GNU General Public License v3.0**. A copy of the license can be found in the `LICENSE` file.
